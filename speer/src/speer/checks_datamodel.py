# generated by datamodel-codegen:
#   filename:  checks.jsonschema
#   timestamp: 2025-01-13T10:45:06+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, RootModel


class Model(RootModel[Any]):
    root: Any


class NamedArgs(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    actionName: str = Field(
        ..., description="Identical to 'name' property of Action entity."
    )
    attempt: Optional[float] = Field(
        None,
        description="Identical to 'attempt' property of CheckRun. Not set for top-level actions.",
    )
    change: float
    checkName: Optional[str] = Field(
        None,
        description="Identical to 'checkName' property of CheckRun. Not set for top-level actions.",
    )
    externalId: Optional[str] = Field(
        None,
        description="Identical to 'externalId' property of CheckRun. Not set for top-level actions.",
    )
    patchset: float


class ActionCallback(BaseModel):
    namedArgs: Optional[NamedArgs] = None


class ActionResult(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    errorMessage: Optional[str] = Field(
        None, description='DEPRECATED: Use `message` instead.'
    )
    message: Optional[str] = Field(
        None, description='An empty errorMessage means success.'
    )
    shouldReload: Optional[bool] = Field(
        None,
        description='If true, then ChecksProvider.fetch() is called. Has the same affect as if the plugin would call announceUpdate(). So just for convenience.',
    )


class AvatarInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    height: float
    url: str
    width: float


class BrandTypePARENTPatchSet(BaseModel):
    pass


class BrandTypeEditPatchSet(BaseModel):
    pass


class BrandTypeStringNumberChangeSubmissionId(RootModel[Union[str, float]]):
    root: Union[str, float] = Field(
        ...,
        description='types and interfaces ========================================================',
    )


class BrandTypeNumberAccountId(RootModel[float]):
    root: float = Field(
        ...,
        description='types and interfaces ========================================================',
    )


class BrandTypeNumberNumericChangeId(RootModel[float]):
    root: float = Field(
        ...,
        description='types and interfaces ========================================================',
    )


class BrandTypeNumberPatchSet(RootModel[float]):
    root: float = Field(
        ...,
        description='types and interfaces ========================================================',
    )


class BrandTypeStringBranchName(RootModel[str]):
    root: str = Field(
        ...,
        description='types and interfaces ========================================================',
    )


class BrandTypeStringChangeId(RootModel[str]):
    root: str = Field(
        ...,
        description='types and interfaces ========================================================',
    )


class BrandTypeStringChangeInfoId(RootModel[str]):
    root: str = Field(
        ...,
        description='types and interfaces ========================================================',
    )


class BrandTypeStringChangeMessageId(RootModel[str]):
    root: str = Field(
        ...,
        description='types and interfaces ========================================================',
    )


class BrandTypeStringCommitId(RootModel[str]):
    root: str = Field(
        ...,
        description='types and interfaces ========================================================',
    )


class BrandTypeStringCustomValue(RootModel[str]):
    root: str = Field(
        ...,
        description='types and interfaces ========================================================',
    )


class BrandTypeStringEmailAddress(RootModel[str]):
    root: str = Field(
        ...,
        description='types and interfaces ========================================================',
    )


class BrandTypeStringGitRef(RootModel[str]):
    root: str = Field(
        ...,
        description='types and interfaces ========================================================',
    )


class BrandTypeStringGpgKeyFingerprint(RootModel[str]):
    root: str = Field(
        ...,
        description='types and interfaces ========================================================',
    )


class BrandTypeStringGpgKeyId(RootModel[str]):
    root: str = Field(
        ...,
        description='types and interfaces ========================================================',
    )


class BrandTypeStringHashtag(RootModel[str]):
    root: str = Field(
        ...,
        description='types and interfaces ========================================================',
    )


class BrandTypeStringOpenPgpUserIds(RootModel[str]):
    root: str = Field(
        ...,
        description='types and interfaces ========================================================',
    )


class BrandTypeStringRepoName(RootModel[str]):
    root: str = Field(
        ...,
        description='types and interfaces ========================================================',
    )


class BrandTypeStringRequirementType(RootModel[str]):
    root: str = Field(
        ...,
        description='types and interfaces ========================================================',
    )


class BrandTypeStringReviewInputTag(RootModel[str]):
    root: str = Field(
        ...,
        description='types and interfaces ========================================================',
    )


class BrandTypeStringTimestamp(RootModel[str]):
    root: str = Field(
        ...,
        description='types and interfaces ========================================================',
    )


class BrandTypeStringTopicName(RootModel[str]):
    root: str = Field(
        ...,
        description='types and interfaces ========================================================',
    )


class BrandTypeStringTrackingId(RootModel[str]):
    root: str = Field(
        ...,
        description='types and interfaces ========================================================',
    )


class Category(Enum):
    SUCCESS = 'SUCCESS'
    INFO = 'INFO'
    WARNING = 'WARNING'
    ERROR = 'ERROR'


class ChangeStatus(Enum):
    ABANDONED = 'ABANDONED'
    MERGED = 'MERGED'
    NEW = 'NEW'


class ChecksApiConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    fetchPollingIntervalSeconds: float = Field(
        ...,
        description='How often should the provider be called for new CheckData while the user navigates change related pages and the browser tab remains visible? Set to 0 to disable polling. Default is 60 seconds.',
    )


class ChecksPluginApi(BaseModel):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class ChecksProvider(BaseModel):
    pass
    model_config = ConfigDict(
        extra='forbid',
    )


class CommentRange(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    end_character: float = Field(
        ..., description='The character position in the end line. (0-based)'
    )
    end_line: float = Field(
        ..., description='The end line number of the range. (1-based)'
    )
    start_character: float = Field(
        ..., description='The character position in the start line. (0-based)'
    )
    start_line: float = Field(
        ..., description='The start line number of the range. (1-based)'
    )


class FetchInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    commands: Optional[Dict[str, str]] = None
    ref: str
    url: str


class FileInfoStatus(Enum):
    A = 'A'
    D = 'D'
    R = 'R'
    C = 'C'
    W = 'W'
    M = 'M'
    U = 'U'
    X = 'X'


class GpgKeyInfoStatus(Enum):
    BAD = 'BAD'
    OK = 'OK'
    TRUSTED = 'TRUSTED'


class HttpMethod(Enum):
    HEAD = 'HEAD'
    POST = 'POST'
    GET = 'GET'
    DELETE = 'DELETE'
    PUT = 'PUT'


class LabelCommonInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = None
    optional: Optional[bool] = None


class LabelNameToValuesMap(RootModel[Optional[Dict[str, List[str]]]]):
    root: Optional[Dict[str, List[str]]] = None


class LabelStatus(Enum):
    OK = 'OK'
    REJECT = 'REJECT'
    MAY = 'MAY'
    NEED = 'NEED'
    IMPOSSIBLE = 'IMPOSSIBLE'
    OPTIONAL = 'OPTIONAL'


class LabelValueToDescriptionMap(RootModel[Optional[Dict[str, str]]]):
    root: Optional[Dict[str, str]] = None


class LinkIcon(Enum):
    external = 'external'
    image = 'image'
    history = 'history'
    download = 'download'
    download_mobile = 'download_mobile'
    help_page = 'help_page'
    report_bug = 'report_bug'
    code = 'code'
    file_present = 'file_present'


class ProblemInfoStatus(Enum):
    FIXED = 'FIXED'
    FIX_FAILED = 'FIX_FAILED'


class Replacement(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    path: str = Field(
        ...,
        description='For example `polygerrit-ui/app/package.json`. `/COMMIT_MSG` is not supported yet.',
    )
    range: CommentRange
    replacement: str


class RequirementStatus(Enum):
    OK = 'OK'
    NOT_READY = 'NOT_READY'
    RULE_ERROR = 'RULE_ERROR'


class ResponseCode(Enum):
    OK = 'OK'
    ERROR = 'ERROR'
    NOT_LOGGED_IN = 'NOT_LOGGED_IN'


class ReviewerState(Enum):
    REVIEWER = 'REVIEWER'
    CC = 'CC'
    REMOVED = 'REMOVED'


class RevisionKind(Enum):
    REWORK = 'REWORK'
    TRIVIAL_REBASE = 'TRIVIAL_REBASE'
    MERGE_FIRST_PARENT_UPDATE = 'MERGE_FIRST_PARENT_UPDATE'
    NO_CODE_CHANGE = 'NO_CODE_CHANGE'
    NO_CHANGE = 'NO_CHANGE'


class RunStatus(Enum):
    RUNNABLE = 'RUNNABLE'
    RUNNING = 'RUNNING'
    SCHEDULED = 'SCHEDULED'
    COMPLETED = 'COMPLETED'


class SubmitRecordInfoStatus(Enum):
    OK = 'OK'
    NOT_READY = 'NOT_READY'
    CLOSED = 'CLOSED'
    FORCED = 'FORCED'
    RULE_ERROR = 'RULE_ERROR'


class SubmitRequirementExpressionInfoStatus(Enum):
    PASS = 'PASS'
    FAIL = 'FAIL'
    ERROR = 'ERROR'
    NOT_EVALUATED = 'NOT_EVALUATED'


class SubmitRequirementStatus(Enum):
    SATISFIED = 'SATISFIED'
    UNSATISFIED = 'UNSATISFIED'
    OVERRIDDEN = 'OVERRIDDEN'
    NOT_APPLICABLE = 'NOT_APPLICABLE'
    ERROR = 'ERROR'
    FORCED = 'FORCED'


class SubmitType(Enum):
    MERGE_IF_NECESSARY = 'MERGE_IF_NECESSARY'
    FAST_FORWARD_ONLY = 'FAST_FORWARD_ONLY'
    REBASE_IF_NECESSARY = 'REBASE_IF_NECESSARY'
    REBASE_ALWAYS = 'REBASE_ALWAYS'
    MERGE_ALWAYS_ = 'MERGE_ALWAYS '
    CHERRY_PICK = 'CHERRY_PICK'
    INHERIT = 'INHERIT'


class TagColor(Enum):
    gray = 'gray'
    yellow = 'yellow'
    pink = 'pink'
    purple = 'purple'
    cyan = 'cyan'
    brown = 'brown'


class VotingRangeInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    max: float
    min: float


class WebLinkInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    image_url: Optional[str] = Field(None, description='URL to the icon of the link.')
    name: str = Field(..., description='The text to be linkified.')
    tooltip: Optional[str] = Field(
        None, description='Tooltip to show when hovering over the link.'
    )
    url: str = Field(..., description='The link URL.')


class BrandType3C22PARENT222C22PatchSet223E(RootModel[Any]):
    root: Any


class BrandType3C22edit222C22PatchSet223E(RootModel[Any]):
    root: Any


class BrandType3CString7Cnumber2C22ChangeSubmissionId223E(RootModel[Any]):
    root: Any


class BrandType3Cnumber2C22AccountId223E(RootModel[Any]):
    root: Any


class BrandType3Cnumber2C22NumericChangeId223E(RootModel[Any]):
    root: Any


class BrandType3Cnumber2C22PatchSet223E(RootModel[Any]):
    root: Any


class BrandType3Cstring2C22BranchName223E(RootModel[Any]):
    root: Any


class BrandType3Cstring2C22ChangeId223E(RootModel[Any]):
    root: Any


class BrandType3Cstring2C22ChangeInfoId223E(RootModel[Any]):
    root: Any


class BrandType3Cstring2C22ChangeMessageId223E(RootModel[Any]):
    root: Any


class BrandType3Cstring2C22CommitId223E(RootModel[Any]):
    root: Any


class BrandType3Cstring2C22CustomValue223E(RootModel[Any]):
    root: Any


class BrandType3Cstring2C22EmailAddress223E(RootModel[Any]):
    root: Any


class BrandType3Cstring2C22GitRef223E(RootModel[Any]):
    root: Any


class BrandType3Cstring2C22GpgKeyFingerprint223E(RootModel[Any]):
    root: Any


class BrandType3Cstring2C22GpgKeyId223E(RootModel[Any]):
    root: Any


class BrandType3Cstring2C22Hashtag223E(RootModel[Any]):
    root: Any


class BrandType3Cstring2C22OpenPgpUserIds223E(RootModel[Any]):
    root: Any


class BrandType3Cstring2C22RepoName223E(RootModel[Any]):
    root: Any


class BrandType3Cstring2C22RequirementType223E(RootModel[Any]):
    root: Any


class BrandType3Cstring2C22ReviewInputTag223E(RootModel[Any]):
    root: Any


class BrandType3Cstring2C22Timestamp223E(RootModel[Any]):
    root: Any


class BrandType3Cstring2C22TopicName223E(RootModel[Any]):
    root: Any


class BrandType3Cstring2C22TrackingId223E(RootModel[Any]):
    root: Any


class AccountId(RootModel[BrandType3Cnumber2C22AccountId223E]):
    root: BrandType3Cnumber2C22AccountId223E


class Action(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    callback: ActionCallback
    disabled: Optional[bool] = Field(
        None,
        description="Renders the action button in a disabled state. That can be useful for actions that are present most of the time, but sometimes don't apply. Then a grayed out button with a tooltip makes it easier for the user to understand why an expected action is not available. The tooltip should then contain a message about why the disabled state was set, not just about what the action would normally do.",
    )
    name: str
    primary: Optional[bool] = Field(
        None,
        description='Primary actions will get a more prominent treatment in the UI. For example primary actions might be rendered as buttons versus just menu entries in an overflow menu.',
    )
    summary: Optional[bool] = Field(
        None,
        description='Summary actions will get an even more prominent treatment in the UI. They will show up in the checks summary right below the commit message. This only affects top-level actions (i.e. actions in FetchResponse).',
    )
    tooltip: Optional[str] = None


class ActionInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    enabled: Optional[bool] = None
    label: Optional[str] = None
    method: Optional[HttpMethod] = None
    title: Optional[str] = None


class ActionNameToActionInfoMap(BaseModel):
    abandon: Optional[ActionInfo] = None
    cherrypick: Optional[ActionInfo] = None
    deleteEdit: Optional[ActionInfo] = None
    download: Optional[ActionInfo] = None
    edit: Optional[ActionInfo] = None
    hashtags: Optional[ActionInfo] = None
    includedIn: Optional[ActionInfo] = None
    move: Optional[ActionInfo] = None
    publishEdit: Optional[ActionInfo] = None
    ready: Optional[ActionInfo] = None
    rebase: Optional[ActionInfo] = None
    rebaseEdit: Optional[ActionInfo] = None
    revert: Optional[ActionInfo] = None
    revert_submission: Optional[ActionInfo] = None
    stopEdit: Optional[ActionInfo] = None
    submit: Optional[ActionInfo] = None
    topic: Optional[ActionInfo] = None
    wip: Optional[ActionInfo] = None


class BranchName(RootModel[BrandType3Cstring2C22BranchName223E]):
    root: BrandType3Cstring2C22BranchName223E


class ChangeId(RootModel[BrandType3Cstring2C22ChangeId223E]):
    root: BrandType3Cstring2C22ChangeId223E


class ChangeInfoId(RootModel[BrandType3Cstring2C22ChangeInfoId223E]):
    root: BrandType3Cstring2C22ChangeInfoId223E


class ChangeMessageId(RootModel[BrandType3Cstring2C22ChangeMessageId223E]):
    root: BrandType3Cstring2C22ChangeMessageId223E


class ChangeSubmissionId(
    RootModel[BrandType3CString7Cnumber2C22ChangeSubmissionId223E]
):
    root: BrandType3CString7Cnumber2C22ChangeSubmissionId223E


class CodePointer(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    path: str
    range: CommentRange


class CommitId(RootModel[BrandType3Cstring2C22CommitId223E]):
    root: BrandType3Cstring2C22CommitId223E = Field(
        ..., description='40 char string, see shorten() util, if you want 7 chars.'
    )


class CustomValue(RootModel[BrandType3Cstring2C22CustomValue223E]):
    root: BrandType3Cstring2C22CustomValue223E


class EditPatchSet(RootModel[BrandType3C22edit222C22PatchSet223E]):
    root: BrandType3C22edit222C22PatchSet223E


class EmailAddress(RootModel[BrandType3Cstring2C22EmailAddress223E]):
    root: BrandType3Cstring2C22EmailAddress223E


class FileInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    binary: Optional[bool] = None
    lines_deleted: Optional[float] = None
    lines_inserted: Optional[float] = None
    new_mode: Optional[float] = None
    old_mode: Optional[float] = None
    old_path: Optional[str] = None
    size: Optional[float] = None
    size_delta: Optional[float] = None
    status: Optional[FileInfoStatus] = None


class Fix(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Optional[str] = None
    replacements: List[Replacement]


class GitRef(RootModel[BrandType3Cstring2C22GitRef223E]):
    root: BrandType3Cstring2C22GitRef223E


class GpgKeyFingerprint(RootModel[BrandType3Cstring2C22GpgKeyFingerprint223E]):
    root: BrandType3Cstring2C22GpgKeyFingerprint223E


class GpgKeyId(RootModel[BrandType3Cstring2C22GpgKeyId223E]):
    root: BrandType3Cstring2C22GpgKeyId223E


class Hashtag(RootModel[BrandType3Cstring2C22Hashtag223E]):
    root: BrandType3Cstring2C22Hashtag223E


class Link(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    icon: LinkIcon
    primary: bool = Field(
        ...,
        description='Primary links will get a more prominent treatment in the UI, e.g. being always visible in the results table or also showing up in the change page summary of checks.',
    )
    tooltip: Optional[str] = None
    url: str = Field(..., description="Must begin with 'http'.")


class NumericChangeId(RootModel[BrandType3Cnumber2C22NumericChangeId223E]):
    root: BrandType3Cnumber2C22NumericChangeId223E


class OpenPgpUserIds(RootModel[BrandType3Cstring2C22OpenPgpUserIds223E]):
    root: BrandType3Cstring2C22OpenPgpUserIds223E


class ParentCommitInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    commit: CommitId
    subject: str


class ParentPatchSet(RootModel[BrandType3C22PARENT222C22PatchSet223E]):
    root: BrandType3C22PARENT222C22PatchSet223E


class PatchSetNumber(RootModel[BrandType3Cnumber2C22PatchSet223E]):
    root: BrandType3Cnumber2C22PatchSet223E


class ProblemInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    message: str
    outcome: Optional[str] = None
    status: Optional[ProblemInfoStatus] = None


class RepoName(RootModel[BrandType3Cstring2C22RepoName223E]):
    root: BrandType3Cstring2C22RepoName223E


class RequirementType(RootModel[BrandType3Cstring2C22RequirementType223E]):
    root: BrandType3Cstring2C22RequirementType223E


class ReviewInputTag(RootModel[BrandType3Cstring2C22ReviewInputTag223E]):
    root: BrandType3Cstring2C22ReviewInputTag223E


class RevisionPatchSetNum(RootModel[Union[PatchSetNumber, EditPatchSet]]):
    root: Union[PatchSetNumber, EditPatchSet]


class SubmitRequirementExpressionInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    error_message: Optional[str] = None
    expression: str
    failing_atoms: Optional[List[str]] = None
    fulfilled: Optional[bool] = None
    passing_atoms: Optional[List[str]] = None
    status: Optional[SubmitRequirementExpressionInfoStatus] = None


class SubmitRequirementResultInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    applicability_expression_result: Optional[SubmitRequirementExpressionInfo] = None
    description: Optional[str] = None
    is_legacy: Optional[bool] = None
    name: str
    override_expression_result: Optional[SubmitRequirementExpressionInfo] = None
    status: SubmitRequirementStatus
    submittability_expression_result: SubmitRequirementExpressionInfo


class Tag(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    color: Optional[TagColor] = None
    name: str
    tooltip: Optional[str] = None


class Timestamp(RootModel[BrandType3Cstring2C22Timestamp223E]):
    root: BrandType3Cstring2C22Timestamp223E


class TopicName(RootModel[BrandType3Cstring2C22TopicName223E]):
    root: BrandType3Cstring2C22TopicName223E


class TrackingId(RootModel[BrandType3Cstring2C22TrackingId223E]):
    root: BrandType3Cstring2C22TrackingId223E


class TrackingIdInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: TrackingId
    system: str


class AccountInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    field_account_id: Optional[AccountId] = Field(None, alias='_account_id')
    field_more_accounts: Optional[bool] = Field(None, alias='_more_accounts')
    avatars: Optional[List[AvatarInfo]] = None
    display_name: Optional[str] = None
    email: Optional[EmailAddress] = None
    inactive: Optional[bool] = None
    name: Optional[str] = None
    secondary_emails: Optional[List[str]] = None
    status: Optional[str] = None
    tags: Optional[List[str]] = None
    username: Optional[str] = None


class ApprovalInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    field_account_id: Optional[AccountId] = Field(None, alias='_account_id')
    field_more_accounts: Optional[bool] = Field(None, alias='_more_accounts')
    avatars: Optional[List[AvatarInfo]] = None
    date: Optional[Timestamp] = None
    display_name: Optional[str] = None
    email: Optional[EmailAddress] = None
    inactive: Optional[bool] = None
    name: Optional[str] = None
    permitted_voting_range: Optional[VotingRangeInfo] = None
    post_submit: Optional[bool] = None
    secondary_emails: Optional[List[str]] = None
    status: Optional[str] = None
    tag: Optional[ReviewInputTag] = None
    tags: Optional[List[str]] = None
    username: Optional[str] = None
    value: Optional[float] = None


class AttentionSetInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    account: AccountInfo
    last_update: Optional[Timestamp] = None
    reason: Optional[str] = None
    reason_account: Optional[AccountInfo] = None


class CheckResult(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    actions: Optional[List[Action]] = Field(
        None,
        description='Callbacks to the plugin. Must be implemented individually by each plugin. Actions are rendered as buttons. If there are more than two actions per result, then further actions are put into an overflow menu. Sort order is defined by the data provider.\n\nExamples: Acknowledge/Dismiss, Delete, Report a bug, Report as not useful, Make blocking, Downgrade severity.',
    )
    category: Category = Field(
        ...,
        description='SUCCESS: Indicates that some build, test or check is passing. A COMPLETED          run without results will also be treated as "passing" and will get          an artificial SUCCESS result. But you can also make this explicit,          which also allows one run to have multiple "passing" results,          maybe along with results of other categories. INFO:    The user will typically not bother to look into this category,          only for looking up something that they are searching for. Can be          used for reporting secondary metrics and analysis, or a wider          range of artifacts produced by the checks system. WARNING: A warning is something that should be read before submitting the          change. The user should not ignore it, but it is also not blocking          submit. It has a similar level of importance as an unresolved          comment. ERROR:   An error indicates that the change must not or cannot be submitted          without fixing the problem. Errors will be visualized very          prominently to the user.\n\nThe ‘tags’ field below can be used for further categorization, e.g. for distinguishing FAILED vs TIMED_OUT.',
    )
    codePointers: Optional[List[CodePointer]] = Field(
        None,
        description='Link to lines of code. The referenced path must be part of this patchset.\n\nOnly one code pointer is supported. If the array contains, more than one pointer, then all the other pointers will be ignored. Support for multiple code pointers will only added on demand.',
    )
    externalId: Optional[str] = Field(
        None,
        description='An optional opaque identifier not used by Gerrit directly, but might be used by plugin extensions and callbacks.',
    )
    fixes: Optional[List[Fix]] = Field(
        None,
        description='Optionally you can provide fixes that would solve the issue reported. The user will then see a "SHOW FIX" button for previewing the fix in a dialog, whichs allows the user to apply the fix. That will create a new EDIT patchset or use the exiting EDIT patchset, so the user can also apply fixes from multiple check results.\n\nNormally, you would only provide one fix, but you can also provide multiple different options to the user to choose from. Each fix may contain one or more replacements, each being a modification of one file. These files do not have to be part of the change yet.',
    )
    links: Optional[List[Link]] = Field(
        None,
        description='Links provide an opportunity for the end-user to easily access details and artifacts. Links are displayed by an icon+tooltip only. They don’t have a name, making them clearly distinguishable from tags and actions.\n\nThere is a fixed set of LinkIcons to choose from, see below.\n\nExamples: Link to test log. Link to result artifacts such as images and screenshots. Link to downloadable artifacts such as ZIP or APK files.',
    )
    message: Optional[str] = Field(
        None,
        description='Exhaustive optional message describing the check result. Will be initially collapsed. Might potentially be very long, e.g. a log of MB size. The UI is not limiting this. Data providing plugins are responsible for not killing the browser. :-)\n\nFor now this is just a plain unformatted string. The only formatting applied is the one that Gerrit also applies to human comments.\n\nTo provide richer formatting to the check result messages you should use the `check-result-expanded` plugin endpoint to attach a Web Component. See `Documentation/pg-plugin-endpoints.txt`.',
    )
    summary: str = Field(
        ...,
        description="Short description of the check result.\n\nIt should be expected that this string might be cut off at ~80 chars in the UI. The full description will then be shown in a tooltip. This is a plain string without styling or formatting options.\n\nExamples: MessageConverterTest failed with: 'kermit' expected, but got 'ernie'. Binary size of javascript bundle has increased by 27%.",
    )
    tags: Optional[List[Tag]] = Field(
        None,
        description='Tags allow a plugins to further categorize a result, e.g. making a list of results filterable by the end-user. The name is free-form, but there is a predefined set of TagColors to choose from with a recommendation of color for common tags, see below.\n\nExamples: PASS, FAIL, SCHEDULED, OBSOLETE, SKIPPED, TIMED_OUT, INFRA_ERROR, FLAKY WIN, MAC, LINUX BUILD, TEST, LINT INTEGRATION, E2E, SCREENSHOT',
    )


class CheckRun(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    actions: Optional[List[Action]] = Field(
        None,
        description='Optional callbacks to the plugin. Must be implemented individually by each plugin. The most important actions (which get special UI treatment) are: "Run" for RUNNABLE and COMPLETED runs. "Cancel" for RUNNING and SCHEDULED runs.',
    )
    attempt: Optional[float] = Field(
        None,
        description='The UI will focus on just the latest attempt per run. Former attempts are accessible, but initially collapsed/hidden. Lower number means older attempt. Every run has its own attempt numbering, so attempt 3 of run A is not directly related to attempt 3 of run B.\n\nThe attempt number must be >=0. Only if you have just one RUNNABLE attempt, then you can leave it undefined.\n\nTBD: Optionally providing aggregate information about former attempts will probably be a useful feature, but we are deferring the exact data modeling of that to later.',
    )
    change: Optional[float] = Field(
        None,
        description='Gerrit requests check runs and results from the plugin by change number and patchset number. So these two properties can as well be left empty when returning results to the Gerrit UI and are thus optional.',
    )
    checkDescription: Optional[str] = Field(
        None,
        description='Optional description of the check. Only shown as a tooltip or in a hovercard.',
    )
    checkLink: Optional[str] = Field(
        None,
        description="Optional http link to an external page with more detailed information about this run. Must begin with 'http'.",
    )
    checkName: str = Field(
        ...,
        description='The unique name of the check. There can’t be two runs with the same change/patchset/attempt/checkName combination. Multiple attempts of the same run must have the same checkName. It should be expected that this string is cut off at ~30 chars in the UI. The full name will then be shown in a tooltip.',
    )
    externalId: Optional[str] = Field(
        None,
        description='An optional opaque identifier not used by Gerrit directly, but might be used by plugin extensions and callbacks.',
    )
    finishedTimestamp: Optional[datetime] = Field(
        None,
        description='For RUNNING runs this is considered to be an estimate of when the run will be finished.',
    )
    labelName: Optional[str] = Field(
        None,
        description='Optional reference to a Gerrit label (e.g. "Verified") that this result influences. Allows the user to understand and navigate the relationship between check runs/results and submit requirements, see also https://gerrit-review.googlesource.com/c/homepage/+/279176.',
    )
    patchset: Optional[float] = Field(
        None,
        description='Typically only runs for the latest patchset are requested and presented. Older runs and their results are only available on request, e.g. by switching to another patchset in a dropdown\n\nTBD: Check data providers may decide that runs and results are applicable to a newer patchset, even if they were produced for an older, e.g. because only the commit message was changed. Maybe that warrants the addition of another optional field, e.g. `original_patchset`.',
    )
    results: Optional[List[CheckResult]] = Field(
        None,
        description='List of results produced by this run. RUNNABLE runs must not have results. RUNNING runs can contain (intermediate) results. Nesting the results in runs enforces that:\n- A run can have 0-n results.\n- A result is associated with exactly one run.',
    )
    scheduledTimestamp: Optional[datetime] = None
    startedTimestamp: Optional[datetime] = None
    status: RunStatus = Field(
        ...,
        description='RUNNABLE:  Not run (yet). Mostly useful for runs that the user can trigger            (see actions) and for indicating that a check was not run at a            later attempt. Cannot contain results. RUNNING:   The run is in progress. SCHEDULED: Refinement of RUNNING: The run was triggered, but is not yet            running. It may have to wait for resources or for some other run            to finish. The UI treats this mostly identical to RUNNING, but            uses a differnt icon. COMPLETED: The attempt of the run has finished. Does not indicate at all            whether the run was successful or not. Outcomes can and should            be modeled using the CheckResult entity.',
    )
    statusDescription: Optional[str] = Field(
        None,
        description='Optional short description of the run status. This is a plain string without styling or formatting options. It will only be shown as a tooltip or in a hovercard.\n\nExamples: "40 tests running, 30 completed: 0 failing so far", "Scheduled 5 minutes ago, not running yet".',
    )
    statusLink: Optional[str] = Field(
        None,
        description="Optional http link to an external page with more detailed information about the run status. Must begin with 'http'.",
    )


class CustomKeyedValues(RootModel[Optional[Dict[str, CustomValue]]]):
    root: Optional[Dict[str, CustomValue]] = None


class DetailedLabelInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    all: Optional[List[ApprovalInfo]] = None
    default_value: Optional[float] = None
    description: Optional[str] = None
    optional: Optional[bool] = None
    values: Optional[LabelValueToDescriptionMap] = None


class FetchResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    actions: Optional[List[Action]] = Field(
        None,
        description='Top-level actions that are not associated with a specific run or result. Will be shown as buttons in the header of the Checks tab.',
    )
    errorMessage: Optional[str] = Field(
        None, description='Only relevant when the responseCode is ERROR.'
    )
    links: Optional[List[Link]] = Field(
        None,
        description='Top-level links that are not associated with a specific run or result. Will be shown as icons in the header of the Checks tab.',
    )
    loginCallback: Optional[Any] = Field(
        None,
        description='Only relevant when the responseCode is NOT_LOGGED_IN. Gerrit displays a "Login" button and calls this callback when the user clicks on the button.',
    )
    responseCode: ResponseCode
    runs: Optional[List[CheckRun]] = None
    summaryMessage: Optional[str] = Field(
        None,
        description='Shown prominently in the change summary below the run chips. Interpreted as markdown.',
    )


class GitPersonInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    date: Timestamp
    email: EmailAddress
    name: str


class GpgKeyInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    fingerprint: Optional[GpgKeyFingerprint] = None
    id: Optional[GpgKeyId] = None
    key: Optional[str] = None
    problems: Optional[List[str]] = None
    status: Optional[GpgKeyInfoStatus] = None
    user_ids: Optional[List[OpenPgpUserIds]] = None


class IdToAttentionSetMap(RootModel[Optional[Dict[str, AttentionSetInfo]]]):
    root: Optional[Dict[str, AttentionSetInfo]] = None


class LabelInfo1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    all: Optional[List[ApprovalInfo]] = None
    approved: Optional[AccountInfo] = None
    blocking: Optional[bool] = None
    default_value: Optional[float] = None
    description: Optional[str] = None
    disliked: Optional[AccountInfo] = None
    optional: Optional[bool] = None
    recommended: Optional[AccountInfo] = None
    rejected: Optional[AccountInfo] = None
    value: Optional[float] = None
    values: Optional[LabelValueToDescriptionMap] = None


class ParentInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    branch_name: Optional[str] = None
    change_id: Optional[ChangeId] = None
    change_number: Optional[NumericChangeId] = None
    change_status: Optional[ChangeStatus] = None
    commit_id: Optional[CommitId] = None
    is_merged_in_target_branch: Optional[bool] = None
    patch_set_number: Optional[PatchSetNumber] = None


class PatchSetNum(RootModel[Union[PatchSetNumber, ParentPatchSet, EditPatchSet]]):
    root: Union[PatchSetNumber, ParentPatchSet, EditPatchSet]


class PushCertificateInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    certificate: str
    key: GpgKeyInfo


class QuickLabelInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    approved: Optional[AccountInfo] = None
    blocking: Optional[bool] = None
    default_value: Optional[float] = None
    description: Optional[str] = None
    disliked: Optional[AccountInfo] = None
    optional: Optional[bool] = None
    recommended: Optional[AccountInfo] = None
    rejected: Optional[AccountInfo] = None
    value: Optional[float] = None


class Requirement(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    fallbackText: str
    status: RequirementStatus
    type: RequirementType


class ReviewerUpdateInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    reviewer: AccountInfo
    state: ReviewerState
    updated: Timestamp
    updated_by: AccountInfo


class Reviewers(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    CC: Optional[List[AccountInfo]] = None
    REMOVED: Optional[List[AccountInfo]] = None
    REVIEWER: Optional[List[AccountInfo]] = None


class SubmitRecordInfoLabel(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    appliedBy: AccountInfo
    label: str
    status: LabelStatus


class ChangeMessageInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    field_revision_number: Optional[PatchSetNum] = Field(None, alias='_revision_number')
    accounts_in_message: Optional[List[AccountInfo]] = None
    author: Optional[AccountInfo] = None
    date: Timestamp
    id: ChangeMessageId
    message: str
    real_author: Optional[AccountInfo] = None
    reviewer: Optional[AccountInfo] = None
    tag: Optional[ReviewInputTag] = None
    updated_by: Optional[AccountInfo] = None


class CommitInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    author: GitPersonInfo
    commit: Optional[CommitId] = None
    committer: GitPersonInfo
    message: str
    parents: List[ParentCommitInfo]
    resolve_conflicts_web_links: Optional[List[WebLinkInfo]] = None
    subject: str
    web_links: Optional[List[WebLinkInfo]] = None


class LabelInfo(RootModel[Union[QuickLabelInfo, DetailedLabelInfo, LabelInfo1]]):
    root: Union[QuickLabelInfo, DetailedLabelInfo, LabelInfo1] = Field(
        ...,
        description='The LabelInfo entity contains information about a label on a change, always corresponding to the current patch set. https://gerrit-review.googlesource.com/Documentation/rest-api-changes.html#label-info',
    )


class LabelNameToInfoMap(RootModel[Optional[Dict[str, LabelInfo]]]):
    root: Optional[Dict[str, LabelInfo]] = None


class RevisionInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    field_number: RevisionPatchSetNum = Field(..., alias='_number')
    commit: Optional[CommitInfo] = None
    commit_with_footers: Optional[str] = None
    created: Timestamp
    description: Optional[str] = None
    fetch: Optional[Dict[str, FetchInfo]] = None
    files: Optional[Dict[str, FileInfo]] = None
    kind: RevisionKind
    parents_data: Optional[List[ParentInfo]] = None
    push_certificate: Optional[PushCertificateInfo] = None
    ref: GitRef
    reviewed: Optional[bool] = None
    uploader: AccountInfo


class SubmitRecordInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    error_message: Optional[str] = None
    labels: Optional[List[SubmitRecordInfoLabel]] = None
    requirements: Optional[List[Requirement]] = None
    rule_name: str
    status: Optional[SubmitRecordInfoStatus] = None


class ChangeInfo(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    field_more_changes: Optional[bool] = Field(None, alias='_more_changes')
    field_number: NumericChangeId = Field(..., alias='_number')
    actions: Optional[ActionNameToActionInfoMap] = None
    attention_set: Optional[IdToAttentionSetMap] = None
    branch: BranchName
    change_id: ChangeId
    cherry_pick_of_change: Optional[NumericChangeId] = None
    cherry_pick_of_patch_set: Optional[RevisionPatchSetNum] = None
    contains_git_conflicts: Optional[bool] = None
    created: Timestamp
    current_revision: Optional[CommitId] = None
    custom_keyed_values: Optional[CustomKeyedValues] = None
    deletions: float
    has_review_started: Optional[bool] = None
    hashtags: Optional[List[Hashtag]] = None
    id: ChangeInfoId
    insertions: float
    is_private: Optional[bool] = None
    labels: Optional[LabelNameToInfoMap] = None
    mergeable: Optional[bool] = None
    messages: Optional[List[ChangeMessageInfo]] = None
    owner: AccountInfo
    pending_reviewers: Optional[List[AccountInfo]] = None
    permitted_labels: Optional[LabelNameToValuesMap] = None
    problems: Optional[List[ProblemInfo]] = None
    project: RepoName
    removable_reviewers: Optional[List[AccountInfo]] = None
    requirements: Optional[List[Requirement]] = None
    revert_of: Optional[NumericChangeId] = None
    reviewer_updates: Optional[List[ReviewerUpdateInfo]] = None
    reviewers: Reviewers
    revisions: Optional[Dict[str, RevisionInfo]] = None
    starred: Optional[bool] = None
    status: ChangeStatus
    subject: str
    submission_id: Optional[ChangeSubmissionId] = None
    submit_records: Optional[List[SubmitRecordInfo]] = None
    submit_requirements: Optional[List[SubmitRequirementResultInfo]] = None
    submit_type: Optional[SubmitType] = None
    submittable: Optional[bool] = None
    submitted: Optional[Timestamp] = None
    submitter: Optional[AccountInfo] = None
    topic: Optional[TopicName] = None
    total_comment_count: Optional[float] = None
    tracking_ids: Optional[List[TrackingIdInfo]] = None
    unresolved_comment_count: Optional[float] = None
    updated: Timestamp
    work_in_progress: Optional[bool] = None


class ChangeData(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    changeInfo: ChangeInfo
    changeNumber: float
    commitMessage: Optional[str] = None
    patchsetNumber: float
    patchsetSha: str
    repo: str
